//
// Condition.cs
//
// Author(s):
//       Alessio Parma <alessio.parma@gmail.com>
//
// Copyright (c) 2012-2016 Alessio Parma <alessio.parma@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY A TEMPLATE ON 01/06/2015 11:23:57.
// DO NOT EDIT THIS FILE BY HAND, EVERY CHANGE WOULD BE LOST ON NEXT TEMPLATE RUN.

namespace Dessert.Events
{
	using System;
	using System.Collections;
    using System.Collections.Generic;
	using System.Diagnostics.Contracts;
	using Collections;
	using Core;
    
	interface IParentCondition : ILinkedList<IParentCondition>
    {
		bool Succeeded { get; }

        void Trigger(SimEvent child);
    }

	#region Condition Evaluators

	public delegate bool ConditionEval<T1>(Condition<T1> condition) 
        where T1 : SimEvent;

	public delegate bool ConditionEval<T1, T2>(Condition<T1, T2> condition) 
        where T1 : SimEvent
        where T2 : SimEvent;

	public delegate bool ConditionEval<T1, T2, T3>(Condition<T1, T2, T3> condition) 
        where T1 : SimEvent
        where T2 : SimEvent
        where T3 : SimEvent;

	public delegate bool ConditionEval<T1, T2, T3, T4>(Condition<T1, T2, T3, T4> condition) 
        where T1 : SimEvent
        where T2 : SimEvent
        where T3 : SimEvent
        where T4 : SimEvent;

	public delegate bool ConditionEval<T1, T2, T3, T4, T5>(Condition<T1, T2, T3, T4, T5> condition) 
        where T1 : SimEvent
        where T2 : SimEvent
        where T3 : SimEvent
        where T4 : SimEvent
        where T5 : SimEvent;

	#endregion

	#region Condition Declarations

	public sealed class Condition<T1> : SimEvent<Condition<T1>, IList<SimEvent>>, IParentCondition 
        where T1 : SimEvent
	{
		readonly FakeReadOnlyList<SimEvent> _succeeded = new FakeReadOnlyList<SimEvent>();
		readonly T1 _ev1;
	
		readonly ConditionEval<T1> _eval;
        State _finalState;

		internal Condition(ConditionEval<T1> eval, T1 ev1) : base(ev1.Env)
        {
            _eval = eval;
			// Some events may have already succeeded (like store put events,
            // container put events, conditions and generic events); therefore,
            // we have to check the condition immediately.
			_ev1 = ev1;
			if (ev1) {
				(this as IParentCondition).Trigger(ev1);
			} else {
				ev1.AddParent(this);			
			}
        }

        void IParentCondition.Trigger(SimEvent child)
        {
            // If condition event has already been solved,
            // then further triggers are not possible.
            if (_finalState == State.Succeeded) {
                return;
            }
			// We add child event to succeeded events and then we check
			// if condition is now verified.
			_succeeded.ForceAdd(child);
			if (!_eval(this)) {
				return;
			}
			// Condition has succeeded, therefore we need to schedule it.
            _finalState = State.Succeeded;
            Env.ScheduleEvent(this);
        }

		#region Public Members

		[Pure]
        public T1 Ev1
        {
            get { return _ev1; }
        }

 
		/// <summary>
        ///   The user defined function used the evaluate the condition.
        /// </summary>
        [Pure]
        public ConditionEval<T1> Eval
        {
            get { return _eval; }
        }

		/// <summary>
		///   Returns a readonly list of events that succeeded
		///   before this condition was satisfied.
		/// </summary>
		/// <return>
		///   A readonly list of events that succeeded
		///   before this condition was satisfied.
		/// </return>    
        [Pure]
		public override IList<SimEvent> Value
        {
            get { return _succeeded; }
        }

        [Pure]
		public static Condition<T1, SimEvent> operator &(Condition<T1> c, SimEvent ev)
		{
			Contract.Requires<ArgumentNullException>(c != null && ev != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c.Env, ev.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, SimEvent>>() != null);
			return new Condition<T1, SimEvent>(ConditionEvaluators.AllEvents, c._ev1, ev);
		}
		
        [Pure]		
		public static Condition<T1, SimEvent> operator |(Condition<T1> c, SimEvent ev)
		{
			Contract.Requires<ArgumentNullException>(c != null && ev != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c.Env, ev.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, SimEvent>>() != null);
			return new Condition<T1, SimEvent>(ConditionEvaluators.AnyEvent, c._ev1, ev);
		}

		[Pure]
		public static Condition<T1, SimEvent> operator &(Condition<T1> c1, Condition<SimEvent> c2)
		{
			Contract.Requires<ArgumentNullException>(c1 != null && c2 != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c1.Env, c2.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, SimEvent>>() != null);
			return new Condition<T1, SimEvent>(ConditionEvaluators.AllEvents, c1._ev1, c2.Ev1);
		}

		[Pure]
		public static Condition<T1, SimEvent> operator |(Condition<T1> c1, Condition<SimEvent> c2)
		{
			Contract.Requires<ArgumentNullException>(c1 != null && c2 != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c1.Env, c2.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, SimEvent>>() != null);
			return new Condition<T1, SimEvent>(ConditionEvaluators.AnyEvent, c1._ev1, c2.Ev1);
		}

		[Pure]
		public static Condition<T1, SimEvent, SimEvent> operator &(Condition<T1> c1, Condition<SimEvent, SimEvent> c2)
		{
			Contract.Requires<ArgumentNullException>(c1 != null && c2 != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c1.Env, c2.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, SimEvent, SimEvent>>() != null);
			return new Condition<T1, SimEvent, SimEvent>(ConditionEvaluators.AllEvents, c1._ev1, c2.Ev1, c2.Ev2);
		}

		[Pure]
		public static Condition<T1, SimEvent, SimEvent> operator |(Condition<T1> c1, Condition<SimEvent, SimEvent> c2)
		{
			Contract.Requires<ArgumentNullException>(c1 != null && c2 != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c1.Env, c2.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, SimEvent, SimEvent>>() != null);
			return new Condition<T1, SimEvent, SimEvent>(ConditionEvaluators.AnyEvent, c1._ev1, c2.Ev1, c2.Ev2);
		}

		[Pure]
		public static Condition<T1, SimEvent, SimEvent, SimEvent> operator &(Condition<T1> c1, Condition<SimEvent, SimEvent, SimEvent> c2)
		{
			Contract.Requires<ArgumentNullException>(c1 != null && c2 != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c1.Env, c2.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, SimEvent, SimEvent, SimEvent>>() != null);
			return new Condition<T1, SimEvent, SimEvent, SimEvent>(ConditionEvaluators.AllEvents, c1._ev1, c2.Ev1, c2.Ev2, c2.Ev3);
		}

		[Pure]
		public static Condition<T1, SimEvent, SimEvent, SimEvent> operator |(Condition<T1> c1, Condition<SimEvent, SimEvent, SimEvent> c2)
		{
			Contract.Requires<ArgumentNullException>(c1 != null && c2 != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c1.Env, c2.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, SimEvent, SimEvent, SimEvent>>() != null);
			return new Condition<T1, SimEvent, SimEvent, SimEvent>(ConditionEvaluators.AnyEvent, c1._ev1, c2.Ev1, c2.Ev2, c2.Ev3);
		}

		[Pure]
		public static Condition<T1, SimEvent, SimEvent, SimEvent, SimEvent> operator &(Condition<T1> c1, Condition<SimEvent, SimEvent, SimEvent, SimEvent> c2)
		{
			Contract.Requires<ArgumentNullException>(c1 != null && c2 != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c1.Env, c2.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, SimEvent, SimEvent, SimEvent, SimEvent>>() != null);
			return new Condition<T1, SimEvent, SimEvent, SimEvent, SimEvent>(ConditionEvaluators.AllEvents, c1._ev1, c2.Ev1, c2.Ev2, c2.Ev3, c2.Ev4);
		}

		[Pure]
		public static Condition<T1, SimEvent, SimEvent, SimEvent, SimEvent> operator |(Condition<T1> c1, Condition<SimEvent, SimEvent, SimEvent, SimEvent> c2)
		{
			Contract.Requires<ArgumentNullException>(c1 != null && c2 != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c1.Env, c2.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, SimEvent, SimEvent, SimEvent, SimEvent>>() != null);
			return new Condition<T1, SimEvent, SimEvent, SimEvent, SimEvent>(ConditionEvaluators.AnyEvent, c1._ev1, c2.Ev1, c2.Ev2, c2.Ev3, c2.Ev4);
		}


		#endregion

        #region ILinkedList Members

        int ICollection<IParentCondition>.Count
        {
            get { return 1; }
        }

        IParentCondition IThinLinkedList<IParentCondition>.First
        {
            get { return this; }
        }

        bool ICollection<IParentCondition>.Contains(IParentCondition item)
        {
            return Equals(item);
        }

        IEnumerator<IParentCondition> IEnumerable<IParentCondition>.GetEnumerator()
        {
            yield return this;
        }

        IEqualityComparer<IParentCondition> IThinLinkedList<IParentCondition>.EqualityComparer
        {
            get { throw new DessertException(ErrorMessages.InvalidMethod); }
        }

        bool ICollection<IParentCondition>.IsReadOnly
        {
            get { throw new DessertException(ErrorMessages.InvalidMethod); }
        }

        IParentCondition ILinkedList<IParentCondition>.Last
        {
            get { throw new DessertException(ErrorMessages.InvalidMethod); }
        }

        void ICollection<IParentCondition>.Add(IParentCondition item)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void IThinLinkedList<IParentCondition>.AddFirst(IParentCondition item)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void ILinkedList<IParentCondition>.AddLast(IParentCondition item)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void ILinkedList<IParentCondition>.Append(ILinkedList<IParentCondition> list)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void ICollection<IParentCondition>.Clear()
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void ICollection<IParentCondition>.CopyTo(IParentCondition[] array, int arrayIndex)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        bool ICollection<IParentCondition>.Remove(IParentCondition item)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        IParentCondition IThinLinkedList<IParentCondition>.RemoveFirst()
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        #endregion
	}
	public sealed class Condition<T1, T2> : SimEvent<Condition<T1, T2>, IList<SimEvent>>, IParentCondition 
        where T1 : SimEvent
        where T2 : SimEvent
	{
		readonly FakeReadOnlyList<SimEvent> _succeeded = new FakeReadOnlyList<SimEvent>();
		readonly T1 _ev1;
		readonly T2 _ev2;
	
		readonly ConditionEval<T1, T2> _eval;
        State _finalState;

		internal Condition(ConditionEval<T1, T2> eval, T1 ev1, T2 ev2) : base(ev1.Env)
        {
            _eval = eval;
			// Some events may have already succeeded (like store put events,
            // container put events, conditions and generic events); therefore,
            // we have to check the condition immediately.
			_ev1 = ev1;
			if (ev1) {
				(this as IParentCondition).Trigger(ev1);
			} else {
				ev1.AddParent(this);			
			}
			_ev2 = ev2;
			if (ev2) {
				(this as IParentCondition).Trigger(ev2);
			} else {
				ev2.AddParent(this);			
			}
        }

        void IParentCondition.Trigger(SimEvent child)
        {
            // If condition event has already been solved,
            // then further triggers are not possible.
            if (_finalState == State.Succeeded) {
                return;
            }
			// We add child event to succeeded events and then we check
			// if condition is now verified.
			_succeeded.ForceAdd(child);
			if (!_eval(this)) {
				return;
			}
			// Condition has succeeded, therefore we need to schedule it.
            _finalState = State.Succeeded;
            Env.ScheduleEvent(this);
        }

		#region Public Members

		[Pure]
        public T1 Ev1
        {
            get { return _ev1; }
        }

		[Pure]
        public T2 Ev2
        {
            get { return _ev2; }
        }

 
		/// <summary>
        ///   The user defined function used the evaluate the condition.
        /// </summary>
        [Pure]
        public ConditionEval<T1, T2> Eval
        {
            get { return _eval; }
        }

		/// <summary>
		///   Returns a readonly list of events that succeeded
		///   before this condition was satisfied.
		/// </summary>
		/// <return>
		///   A readonly list of events that succeeded
		///   before this condition was satisfied.
		/// </return>    
        [Pure]
		public override IList<SimEvent> Value
        {
            get { return _succeeded; }
        }

        [Pure]
		public static Condition<T1, T2, SimEvent> operator &(Condition<T1, T2> c, SimEvent ev)
		{
			Contract.Requires<ArgumentNullException>(c != null && ev != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c.Env, ev.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, T2, SimEvent>>() != null);
			return new Condition<T1, T2, SimEvent>(ConditionEvaluators.AllEvents, c._ev1, c._ev2, ev);
		}
		
        [Pure]		
		public static Condition<T1, T2, SimEvent> operator |(Condition<T1, T2> c, SimEvent ev)
		{
			Contract.Requires<ArgumentNullException>(c != null && ev != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c.Env, ev.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, T2, SimEvent>>() != null);
			return new Condition<T1, T2, SimEvent>(ConditionEvaluators.AnyEvent, c._ev1, c._ev2, ev);
		}

		[Pure]
		public static Condition<T1, T2, SimEvent> operator &(Condition<T1, T2> c1, Condition<SimEvent> c2)
		{
			Contract.Requires<ArgumentNullException>(c1 != null && c2 != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c1.Env, c2.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, T2, SimEvent>>() != null);
			return new Condition<T1, T2, SimEvent>(ConditionEvaluators.AllEvents, c1._ev1, c1._ev2, c2.Ev1);
		}

		[Pure]
		public static Condition<T1, T2, SimEvent> operator |(Condition<T1, T2> c1, Condition<SimEvent> c2)
		{
			Contract.Requires<ArgumentNullException>(c1 != null && c2 != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c1.Env, c2.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, T2, SimEvent>>() != null);
			return new Condition<T1, T2, SimEvent>(ConditionEvaluators.AnyEvent, c1._ev1, c1._ev2, c2.Ev1);
		}

		[Pure]
		public static Condition<T1, T2, SimEvent, SimEvent> operator &(Condition<T1, T2> c1, Condition<SimEvent, SimEvent> c2)
		{
			Contract.Requires<ArgumentNullException>(c1 != null && c2 != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c1.Env, c2.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, T2, SimEvent, SimEvent>>() != null);
			return new Condition<T1, T2, SimEvent, SimEvent>(ConditionEvaluators.AllEvents, c1._ev1, c1._ev2, c2.Ev1, c2.Ev2);
		}

		[Pure]
		public static Condition<T1, T2, SimEvent, SimEvent> operator |(Condition<T1, T2> c1, Condition<SimEvent, SimEvent> c2)
		{
			Contract.Requires<ArgumentNullException>(c1 != null && c2 != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c1.Env, c2.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, T2, SimEvent, SimEvent>>() != null);
			return new Condition<T1, T2, SimEvent, SimEvent>(ConditionEvaluators.AnyEvent, c1._ev1, c1._ev2, c2.Ev1, c2.Ev2);
		}

		[Pure]
		public static Condition<T1, T2, SimEvent, SimEvent, SimEvent> operator &(Condition<T1, T2> c1, Condition<SimEvent, SimEvent, SimEvent> c2)
		{
			Contract.Requires<ArgumentNullException>(c1 != null && c2 != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c1.Env, c2.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, T2, SimEvent, SimEvent, SimEvent>>() != null);
			return new Condition<T1, T2, SimEvent, SimEvent, SimEvent>(ConditionEvaluators.AllEvents, c1._ev1, c1._ev2, c2.Ev1, c2.Ev2, c2.Ev3);
		}

		[Pure]
		public static Condition<T1, T2, SimEvent, SimEvent, SimEvent> operator |(Condition<T1, T2> c1, Condition<SimEvent, SimEvent, SimEvent> c2)
		{
			Contract.Requires<ArgumentNullException>(c1 != null && c2 != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c1.Env, c2.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, T2, SimEvent, SimEvent, SimEvent>>() != null);
			return new Condition<T1, T2, SimEvent, SimEvent, SimEvent>(ConditionEvaluators.AnyEvent, c1._ev1, c1._ev2, c2.Ev1, c2.Ev2, c2.Ev3);
		}


		#endregion

        #region ILinkedList Members

        int ICollection<IParentCondition>.Count
        {
            get { return 1; }
        }

        IParentCondition IThinLinkedList<IParentCondition>.First
        {
            get { return this; }
        }

        bool ICollection<IParentCondition>.Contains(IParentCondition item)
        {
            return Equals(item);
        }

        IEnumerator<IParentCondition> IEnumerable<IParentCondition>.GetEnumerator()
        {
            yield return this;
        }

        IEqualityComparer<IParentCondition> IThinLinkedList<IParentCondition>.EqualityComparer
        {
            get { throw new DessertException(ErrorMessages.InvalidMethod); }
        }

        bool ICollection<IParentCondition>.IsReadOnly
        {
            get { throw new DessertException(ErrorMessages.InvalidMethod); }
        }

        IParentCondition ILinkedList<IParentCondition>.Last
        {
            get { throw new DessertException(ErrorMessages.InvalidMethod); }
        }

        void ICollection<IParentCondition>.Add(IParentCondition item)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void IThinLinkedList<IParentCondition>.AddFirst(IParentCondition item)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void ILinkedList<IParentCondition>.AddLast(IParentCondition item)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void ILinkedList<IParentCondition>.Append(ILinkedList<IParentCondition> list)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void ICollection<IParentCondition>.Clear()
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void ICollection<IParentCondition>.CopyTo(IParentCondition[] array, int arrayIndex)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        bool ICollection<IParentCondition>.Remove(IParentCondition item)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        IParentCondition IThinLinkedList<IParentCondition>.RemoveFirst()
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        #endregion
	}
	public sealed class Condition<T1, T2, T3> : SimEvent<Condition<T1, T2, T3>, IList<SimEvent>>, IParentCondition 
        where T1 : SimEvent
        where T2 : SimEvent
        where T3 : SimEvent
	{
		readonly FakeReadOnlyList<SimEvent> _succeeded = new FakeReadOnlyList<SimEvent>();
		readonly T1 _ev1;
		readonly T2 _ev2;
		readonly T3 _ev3;
	
		readonly ConditionEval<T1, T2, T3> _eval;
        State _finalState;

		internal Condition(ConditionEval<T1, T2, T3> eval, T1 ev1, T2 ev2, T3 ev3) : base(ev1.Env)
        {
            _eval = eval;
			// Some events may have already succeeded (like store put events,
            // container put events, conditions and generic events); therefore,
            // we have to check the condition immediately.
			_ev1 = ev1;
			if (ev1) {
				(this as IParentCondition).Trigger(ev1);
			} else {
				ev1.AddParent(this);			
			}
			_ev2 = ev2;
			if (ev2) {
				(this as IParentCondition).Trigger(ev2);
			} else {
				ev2.AddParent(this);			
			}
			_ev3 = ev3;
			if (ev3) {
				(this as IParentCondition).Trigger(ev3);
			} else {
				ev3.AddParent(this);			
			}
        }

        void IParentCondition.Trigger(SimEvent child)
        {
            // If condition event has already been solved,
            // then further triggers are not possible.
            if (_finalState == State.Succeeded) {
                return;
            }
			// We add child event to succeeded events and then we check
			// if condition is now verified.
			_succeeded.ForceAdd(child);
			if (!_eval(this)) {
				return;
			}
			// Condition has succeeded, therefore we need to schedule it.
            _finalState = State.Succeeded;
            Env.ScheduleEvent(this);
        }

		#region Public Members

		[Pure]
        public T1 Ev1
        {
            get { return _ev1; }
        }

		[Pure]
        public T2 Ev2
        {
            get { return _ev2; }
        }

		[Pure]
        public T3 Ev3
        {
            get { return _ev3; }
        }

 
		/// <summary>
        ///   The user defined function used the evaluate the condition.
        /// </summary>
        [Pure]
        public ConditionEval<T1, T2, T3> Eval
        {
            get { return _eval; }
        }

		/// <summary>
		///   Returns a readonly list of events that succeeded
		///   before this condition was satisfied.
		/// </summary>
		/// <return>
		///   A readonly list of events that succeeded
		///   before this condition was satisfied.
		/// </return>    
        [Pure]
		public override IList<SimEvent> Value
        {
            get { return _succeeded; }
        }

        [Pure]
		public static Condition<T1, T2, T3, SimEvent> operator &(Condition<T1, T2, T3> c, SimEvent ev)
		{
			Contract.Requires<ArgumentNullException>(c != null && ev != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c.Env, ev.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, T2, T3, SimEvent>>() != null);
			return new Condition<T1, T2, T3, SimEvent>(ConditionEvaluators.AllEvents, c._ev1, c._ev2, c._ev3, ev);
		}
		
        [Pure]		
		public static Condition<T1, T2, T3, SimEvent> operator |(Condition<T1, T2, T3> c, SimEvent ev)
		{
			Contract.Requires<ArgumentNullException>(c != null && ev != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c.Env, ev.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, T2, T3, SimEvent>>() != null);
			return new Condition<T1, T2, T3, SimEvent>(ConditionEvaluators.AnyEvent, c._ev1, c._ev2, c._ev3, ev);
		}

		[Pure]
		public static Condition<T1, T2, T3, SimEvent> operator &(Condition<T1, T2, T3> c1, Condition<SimEvent> c2)
		{
			Contract.Requires<ArgumentNullException>(c1 != null && c2 != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c1.Env, c2.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, T2, T3, SimEvent>>() != null);
			return new Condition<T1, T2, T3, SimEvent>(ConditionEvaluators.AllEvents, c1._ev1, c1._ev2, c1._ev3, c2.Ev1);
		}

		[Pure]
		public static Condition<T1, T2, T3, SimEvent> operator |(Condition<T1, T2, T3> c1, Condition<SimEvent> c2)
		{
			Contract.Requires<ArgumentNullException>(c1 != null && c2 != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c1.Env, c2.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, T2, T3, SimEvent>>() != null);
			return new Condition<T1, T2, T3, SimEvent>(ConditionEvaluators.AnyEvent, c1._ev1, c1._ev2, c1._ev3, c2.Ev1);
		}

		[Pure]
		public static Condition<T1, T2, T3, SimEvent, SimEvent> operator &(Condition<T1, T2, T3> c1, Condition<SimEvent, SimEvent> c2)
		{
			Contract.Requires<ArgumentNullException>(c1 != null && c2 != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c1.Env, c2.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, T2, T3, SimEvent, SimEvent>>() != null);
			return new Condition<T1, T2, T3, SimEvent, SimEvent>(ConditionEvaluators.AllEvents, c1._ev1, c1._ev2, c1._ev3, c2.Ev1, c2.Ev2);
		}

		[Pure]
		public static Condition<T1, T2, T3, SimEvent, SimEvent> operator |(Condition<T1, T2, T3> c1, Condition<SimEvent, SimEvent> c2)
		{
			Contract.Requires<ArgumentNullException>(c1 != null && c2 != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c1.Env, c2.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, T2, T3, SimEvent, SimEvent>>() != null);
			return new Condition<T1, T2, T3, SimEvent, SimEvent>(ConditionEvaluators.AnyEvent, c1._ev1, c1._ev2, c1._ev3, c2.Ev1, c2.Ev2);
		}


		#endregion

        #region ILinkedList Members

        int ICollection<IParentCondition>.Count
        {
            get { return 1; }
        }

        IParentCondition IThinLinkedList<IParentCondition>.First
        {
            get { return this; }
        }

        bool ICollection<IParentCondition>.Contains(IParentCondition item)
        {
            return Equals(item);
        }

        IEnumerator<IParentCondition> IEnumerable<IParentCondition>.GetEnumerator()
        {
            yield return this;
        }

        IEqualityComparer<IParentCondition> IThinLinkedList<IParentCondition>.EqualityComparer
        {
            get { throw new DessertException(ErrorMessages.InvalidMethod); }
        }

        bool ICollection<IParentCondition>.IsReadOnly
        {
            get { throw new DessertException(ErrorMessages.InvalidMethod); }
        }

        IParentCondition ILinkedList<IParentCondition>.Last
        {
            get { throw new DessertException(ErrorMessages.InvalidMethod); }
        }

        void ICollection<IParentCondition>.Add(IParentCondition item)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void IThinLinkedList<IParentCondition>.AddFirst(IParentCondition item)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void ILinkedList<IParentCondition>.AddLast(IParentCondition item)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void ILinkedList<IParentCondition>.Append(ILinkedList<IParentCondition> list)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void ICollection<IParentCondition>.Clear()
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void ICollection<IParentCondition>.CopyTo(IParentCondition[] array, int arrayIndex)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        bool ICollection<IParentCondition>.Remove(IParentCondition item)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        IParentCondition IThinLinkedList<IParentCondition>.RemoveFirst()
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        #endregion
	}
	public sealed class Condition<T1, T2, T3, T4> : SimEvent<Condition<T1, T2, T3, T4>, IList<SimEvent>>, IParentCondition 
        where T1 : SimEvent
        where T2 : SimEvent
        where T3 : SimEvent
        where T4 : SimEvent
	{
		readonly FakeReadOnlyList<SimEvent> _succeeded = new FakeReadOnlyList<SimEvent>();
		readonly T1 _ev1;
		readonly T2 _ev2;
		readonly T3 _ev3;
		readonly T4 _ev4;
	
		readonly ConditionEval<T1, T2, T3, T4> _eval;
        State _finalState;

		internal Condition(ConditionEval<T1, T2, T3, T4> eval, T1 ev1, T2 ev2, T3 ev3, T4 ev4) : base(ev1.Env)
        {
            _eval = eval;
			// Some events may have already succeeded (like store put events,
            // container put events, conditions and generic events); therefore,
            // we have to check the condition immediately.
			_ev1 = ev1;
			if (ev1) {
				(this as IParentCondition).Trigger(ev1);
			} else {
				ev1.AddParent(this);			
			}
			_ev2 = ev2;
			if (ev2) {
				(this as IParentCondition).Trigger(ev2);
			} else {
				ev2.AddParent(this);			
			}
			_ev3 = ev3;
			if (ev3) {
				(this as IParentCondition).Trigger(ev3);
			} else {
				ev3.AddParent(this);			
			}
			_ev4 = ev4;
			if (ev4) {
				(this as IParentCondition).Trigger(ev4);
			} else {
				ev4.AddParent(this);			
			}
        }

        void IParentCondition.Trigger(SimEvent child)
        {
            // If condition event has already been solved,
            // then further triggers are not possible.
            if (_finalState == State.Succeeded) {
                return;
            }
			// We add child event to succeeded events and then we check
			// if condition is now verified.
			_succeeded.ForceAdd(child);
			if (!_eval(this)) {
				return;
			}
			// Condition has succeeded, therefore we need to schedule it.
            _finalState = State.Succeeded;
            Env.ScheduleEvent(this);
        }

		#region Public Members

		[Pure]
        public T1 Ev1
        {
            get { return _ev1; }
        }

		[Pure]
        public T2 Ev2
        {
            get { return _ev2; }
        }

		[Pure]
        public T3 Ev3
        {
            get { return _ev3; }
        }

		[Pure]
        public T4 Ev4
        {
            get { return _ev4; }
        }

 
		/// <summary>
        ///   The user defined function used the evaluate the condition.
        /// </summary>
        [Pure]
        public ConditionEval<T1, T2, T3, T4> Eval
        {
            get { return _eval; }
        }

		/// <summary>
		///   Returns a readonly list of events that succeeded
		///   before this condition was satisfied.
		/// </summary>
		/// <return>
		///   A readonly list of events that succeeded
		///   before this condition was satisfied.
		/// </return>    
        [Pure]
		public override IList<SimEvent> Value
        {
            get { return _succeeded; }
        }

        [Pure]
		public static Condition<T1, T2, T3, T4, SimEvent> operator &(Condition<T1, T2, T3, T4> c, SimEvent ev)
		{
			Contract.Requires<ArgumentNullException>(c != null && ev != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c.Env, ev.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, T2, T3, T4, SimEvent>>() != null);
			return new Condition<T1, T2, T3, T4, SimEvent>(ConditionEvaluators.AllEvents, c._ev1, c._ev2, c._ev3, c._ev4, ev);
		}
		
        [Pure]		
		public static Condition<T1, T2, T3, T4, SimEvent> operator |(Condition<T1, T2, T3, T4> c, SimEvent ev)
		{
			Contract.Requires<ArgumentNullException>(c != null && ev != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c.Env, ev.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, T2, T3, T4, SimEvent>>() != null);
			return new Condition<T1, T2, T3, T4, SimEvent>(ConditionEvaluators.AnyEvent, c._ev1, c._ev2, c._ev3, c._ev4, ev);
		}

		[Pure]
		public static Condition<T1, T2, T3, T4, SimEvent> operator &(Condition<T1, T2, T3, T4> c1, Condition<SimEvent> c2)
		{
			Contract.Requires<ArgumentNullException>(c1 != null && c2 != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c1.Env, c2.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, T2, T3, T4, SimEvent>>() != null);
			return new Condition<T1, T2, T3, T4, SimEvent>(ConditionEvaluators.AllEvents, c1._ev1, c1._ev2, c1._ev3, c1._ev4, c2.Ev1);
		}

		[Pure]
		public static Condition<T1, T2, T3, T4, SimEvent> operator |(Condition<T1, T2, T3, T4> c1, Condition<SimEvent> c2)
		{
			Contract.Requires<ArgumentNullException>(c1 != null && c2 != null, ErrorMessages.NullEvent);
            Contract.Requires<ArgumentException>(ReferenceEquals(c1.Env, c2.Env), ErrorMessages.DifferentEnvironment);
		    Contract.Ensures(Contract.Result<Condition<T1, T2, T3, T4, SimEvent>>() != null);
			return new Condition<T1, T2, T3, T4, SimEvent>(ConditionEvaluators.AnyEvent, c1._ev1, c1._ev2, c1._ev3, c1._ev4, c2.Ev1);
		}


		#endregion

        #region ILinkedList Members

        int ICollection<IParentCondition>.Count
        {
            get { return 1; }
        }

        IParentCondition IThinLinkedList<IParentCondition>.First
        {
            get { return this; }
        }

        bool ICollection<IParentCondition>.Contains(IParentCondition item)
        {
            return Equals(item);
        }

        IEnumerator<IParentCondition> IEnumerable<IParentCondition>.GetEnumerator()
        {
            yield return this;
        }

        IEqualityComparer<IParentCondition> IThinLinkedList<IParentCondition>.EqualityComparer
        {
            get { throw new DessertException(ErrorMessages.InvalidMethod); }
        }

        bool ICollection<IParentCondition>.IsReadOnly
        {
            get { throw new DessertException(ErrorMessages.InvalidMethod); }
        }

        IParentCondition ILinkedList<IParentCondition>.Last
        {
            get { throw new DessertException(ErrorMessages.InvalidMethod); }
        }

        void ICollection<IParentCondition>.Add(IParentCondition item)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void IThinLinkedList<IParentCondition>.AddFirst(IParentCondition item)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void ILinkedList<IParentCondition>.AddLast(IParentCondition item)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void ILinkedList<IParentCondition>.Append(ILinkedList<IParentCondition> list)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void ICollection<IParentCondition>.Clear()
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void ICollection<IParentCondition>.CopyTo(IParentCondition[] array, int arrayIndex)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        bool ICollection<IParentCondition>.Remove(IParentCondition item)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        IParentCondition IThinLinkedList<IParentCondition>.RemoveFirst()
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        #endregion
	}
	public sealed class Condition<T1, T2, T3, T4, T5> : SimEvent<Condition<T1, T2, T3, T4, T5>, IList<SimEvent>>, IParentCondition 
        where T1 : SimEvent
        where T2 : SimEvent
        where T3 : SimEvent
        where T4 : SimEvent
        where T5 : SimEvent
	{
		readonly FakeReadOnlyList<SimEvent> _succeeded = new FakeReadOnlyList<SimEvent>();
		readonly T1 _ev1;
		readonly T2 _ev2;
		readonly T3 _ev3;
		readonly T4 _ev4;
		readonly T5 _ev5;
	
		readonly ConditionEval<T1, T2, T3, T4, T5> _eval;
        State _finalState;

		internal Condition(ConditionEval<T1, T2, T3, T4, T5> eval, T1 ev1, T2 ev2, T3 ev3, T4 ev4, T5 ev5) : base(ev1.Env)
        {
            _eval = eval;
			// Some events may have already succeeded (like store put events,
            // container put events, conditions and generic events); therefore,
            // we have to check the condition immediately.
			_ev1 = ev1;
			if (ev1) {
				(this as IParentCondition).Trigger(ev1);
			} else {
				ev1.AddParent(this);			
			}
			_ev2 = ev2;
			if (ev2) {
				(this as IParentCondition).Trigger(ev2);
			} else {
				ev2.AddParent(this);			
			}
			_ev3 = ev3;
			if (ev3) {
				(this as IParentCondition).Trigger(ev3);
			} else {
				ev3.AddParent(this);			
			}
			_ev4 = ev4;
			if (ev4) {
				(this as IParentCondition).Trigger(ev4);
			} else {
				ev4.AddParent(this);			
			}
			_ev5 = ev5;
			if (ev5) {
				(this as IParentCondition).Trigger(ev5);
			} else {
				ev5.AddParent(this);			
			}
        }

        void IParentCondition.Trigger(SimEvent child)
        {
            // If condition event has already been solved,
            // then further triggers are not possible.
            if (_finalState == State.Succeeded) {
                return;
            }
			// We add child event to succeeded events and then we check
			// if condition is now verified.
			_succeeded.ForceAdd(child);
			if (!_eval(this)) {
				return;
			}
			// Condition has succeeded, therefore we need to schedule it.
            _finalState = State.Succeeded;
            Env.ScheduleEvent(this);
        }

		#region Public Members

		[Pure]
        public T1 Ev1
        {
            get { return _ev1; }
        }

		[Pure]
        public T2 Ev2
        {
            get { return _ev2; }
        }

		[Pure]
        public T3 Ev3
        {
            get { return _ev3; }
        }

		[Pure]
        public T4 Ev4
        {
            get { return _ev4; }
        }

		[Pure]
        public T5 Ev5
        {
            get { return _ev5; }
        }

 
		/// <summary>
        ///   The user defined function used the evaluate the condition.
        /// </summary>
        [Pure]
        public ConditionEval<T1, T2, T3, T4, T5> Eval
        {
            get { return _eval; }
        }

		/// <summary>
		///   Returns a readonly list of events that succeeded
		///   before this condition was satisfied.
		/// </summary>
		/// <return>
		///   A readonly list of events that succeeded
		///   before this condition was satisfied.
		/// </return>    
        [Pure]
		public override IList<SimEvent> Value
        {
            get { return _succeeded; }
        }



		#endregion

        #region ILinkedList Members

        int ICollection<IParentCondition>.Count
        {
            get { return 1; }
        }

        IParentCondition IThinLinkedList<IParentCondition>.First
        {
            get { return this; }
        }

        bool ICollection<IParentCondition>.Contains(IParentCondition item)
        {
            return Equals(item);
        }

        IEnumerator<IParentCondition> IEnumerable<IParentCondition>.GetEnumerator()
        {
            yield return this;
        }

        IEqualityComparer<IParentCondition> IThinLinkedList<IParentCondition>.EqualityComparer
        {
            get { throw new DessertException(ErrorMessages.InvalidMethod); }
        }

        bool ICollection<IParentCondition>.IsReadOnly
        {
            get { throw new DessertException(ErrorMessages.InvalidMethod); }
        }

        IParentCondition ILinkedList<IParentCondition>.Last
        {
            get { throw new DessertException(ErrorMessages.InvalidMethod); }
        }

        void ICollection<IParentCondition>.Add(IParentCondition item)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void IThinLinkedList<IParentCondition>.AddFirst(IParentCondition item)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void ILinkedList<IParentCondition>.AddLast(IParentCondition item)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void ILinkedList<IParentCondition>.Append(ILinkedList<IParentCondition> list)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void ICollection<IParentCondition>.Clear()
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        void ICollection<IParentCondition>.CopyTo(IParentCondition[] array, int arrayIndex)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        bool ICollection<IParentCondition>.Remove(IParentCondition item)
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        IParentCondition IThinLinkedList<IParentCondition>.RemoveFirst()
        {
            throw new DessertException(ErrorMessages.InvalidMethod);
        }

        #endregion
	}

	#endregion
}

